name: Release QA and Production

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:
    inputs:
      source_run_id:
        description: "GitHub Actions run id del pipeline CI del TP04"
        required: true
        type: string
      deploy_qa:
        description: "Desplegar QA"
        required: true
        default: true
        type: boolean
      deploy_prod:
        description: "Desplegar Produccion (requiere aprobacion manual)"
        required: true
        default: true
        type: boolean

permissions:
  contents: read
  actions: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  resolve-run:
    runs-on: ubuntu-latest
    if: >-
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'main') ||
      github.event_name == 'workflow_dispatch'
    outputs:
      source_run_id: ${{ steps.pick.outputs.source_run_id }}
      deploy_qa: ${{ steps.pick.outputs.deploy_qa }}
      deploy_prod: ${{ steps.pick.outputs.deploy_prod }}
    steps:
      - name: Resolve source run id and flags
        id: pick
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "source_run_id=${{ github.event.workflow_run.id }}" >> "$GITHUB_OUTPUT"
            echo "deploy_qa=true" >> "$GITHUB_OUTPUT"
            echo "deploy_prod=true" >> "$GITHUB_OUTPUT"
          else
            echo "source_run_id=${{ inputs.source_run_id }}" >> "$GITHUB_OUTPUT"
            echo "deploy_qa=${{ inputs.deploy_qa }}" >> "$GITHUB_OUTPUT"
            echo "deploy_prod=${{ inputs.deploy_prod }}" >> "$GITHUB_OUTPUT"
          fi

  deploy-qa:
    name: Deploy QA
    runs-on: ubuntu-latest
    needs: resolve-run
    if: needs.resolve-run.outputs.deploy_qa == 'true'
    environment: qa
    steps:
      - name: Download front artifact from CI run
        uses: actions/download-artifact@v4
        with:
          name: front-dist
          run-id: ${{ needs.resolve-run.outputs.source_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: artifacts/front-dist

      - name: Download back artifact from CI run
        uses: actions/download-artifact@v4
        with:
          name: back-dist
          run-id: ${{ needs.resolve-run.outputs.source_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: artifacts/back-dist

      - name: Verify artifacts
        run: |
          test -d artifacts/front-dist
          test -d artifacts/back-dist
          echo "Artifacts from CI run ${{ needs.resolve-run.outputs.source_run_id }} ready"

      - name: Trigger Render deploy (Back QA)
        run: |
          curl --fail --show-error --silent \
            -X POST "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID_BACK_QA }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{}'

      - name: Trigger Render deploy (Front QA)
        run: |
          curl --fail --show-error --silent \
            -X POST "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID_FRONT_QA }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{}'

      - name: Wait and health check QA
        run: |
          for i in {1..20}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.BACK_QA_URL }}/health" || true)
            if [ "$code" = "200" ]; then
              echo "QA health check OK"
              exit 0
            fi
            echo "QA not ready yet (attempt $i), code=$code"
            sleep 15
          done
          echo "QA health check failed"
          exit 1

      - name: Checkout repository (for post-deploy tests)
        uses: actions/checkout@v4

      - name: Setup Node (post-deploy QA tests)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: front/package-lock.json

      - name: Verify QA URLs for post-deploy tests
        run: |
          if [ -z "${{ secrets.FRONT_QA_URL }}" ] || [ -z "${{ secrets.BACK_QA_URL }}" ]; then
            echo "Faltan secrets para pruebas post-deploy QA: FRONT_QA_URL y/o BACK_QA_URL" >&2
            exit 1
          fi

      - name: Install frontend dependencies (post-deploy QA tests)
        run: npm install --prefix front

      - name: Run Cypress E2E against QA (with JUnit report)
        run: |
          mkdir -p front/test-results/cypress
          cd front
          CYPRESS_BASE_URL="${{ secrets.FRONT_QA_URL }}" \
          CYPRESS_API_URL="${{ secrets.BACK_QA_URL }}" \
          npm run e2e -- \
            --reporter junit \
            --reporter-options "mochaFile=test-results/cypress/e2e-qa-[hash].xml,toConsole=true"

      - name: Upload Cypress JUnit report for QA (formal)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-e2e-junit-qa
          path: front/test-results/cypress/*.xml
          if-no-files-found: warn

      - name: Resumen E2E QA (visible sin descargar)
        if: always()
        run: |
          shopt -s nullglob
          REPORT_FILES=(front/test-results/cypress/*.xml)

          if [ ${#REPORT_FILES[@]} -eq 0 ]; then
            {
              echo "### E2E Cypress QA"
              echo ""
              echo "No se encontro reporte JUnit de Cypress."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          STATS=$(node -e '
            const fs = require("fs");
            const files = process.argv.slice(1);
            const attr = (s, k) => {
              const m = s.match(new RegExp(`\\b${k}="([0-9]+)"`));
              return m ? Number(m[1]) : 0;
            };
            let tests = 0, failures = 0, errors = 0, skipped = 0;
            for (const f of files) {
              const xml = fs.readFileSync(f, "utf8");
              for (const m of xml.matchAll(/<testsuite\b([^>]*)>/g)) {
                const a = m[1] || "";
                tests += attr(a, "tests");
                failures += attr(a, "failures");
                errors += attr(a, "errors");
                skipped += attr(a, "skipped");
              }
            }
            process.stdout.write(`${tests} ${failures} ${errors} ${skipped}`);
          ' "${REPORT_FILES[@]}" || echo "0 0 0 0")
          set -- $STATS
          TESTS=${1:-0}
          FAILURES=${2:-0}
          ERRORS=${3:-0}
          SKIPPED=${4:-0}

          TEST_CASES=$(node -e '
            const fs = require("fs");
            const files = process.argv.slice(1);
            const names = [];
            for (const f of files) {
              const xml = fs.readFileSync(f, "utf8");
              const re = /<testcase\b([^>]*)>([\s\S]*?)<\/testcase>|<testcase\b([^>]*)\/>/g;
              for (const m of xml.matchAll(re)) {
                const attrs = m[1] || m[3] || "";
                const name = (attrs.match(/\bname="([^"]*)"/) || [])[1] || "";
                const cls = (attrs.match(/\bclassname="([^"]*)"/) || [])[1] || "";
                if (name) names.push(cls ? `${cls} :: ${name}` : name);
              }
            }
            process.stdout.write(names.join("\n"));
          ' "${REPORT_FILES[@]}" || true)

          FAILED_TEST_CASES=$(node -e '
            const fs = require("fs");
            const files = process.argv.slice(1);
            const failed = [];
            for (const f of files) {
              const xml = fs.readFileSync(f, "utf8");
              const re = /<testcase\b([^>]*)>([\s\S]*?)<\/testcase>|<testcase\b([^>]*)\/>/g;
              for (const m of xml.matchAll(re)) {
                const attrs = m[1] || m[3] || "";
                const body = m[2] || "";
                const name = (attrs.match(/\bname="([^"]*)"/) || [])[1] || "";
                const cls = (attrs.match(/\bclassname="([^"]*)"/) || [])[1] || "";
                if (!name) continue;
                if (/<(failure|error)\b/.test(body)) failed.push(cls ? `${cls} :: ${name}` : name);
              }
            }
            process.stdout.write(failed.join("\n"));
          ' "${REPORT_FILES[@]}" || true)

          {
            echo "### E2E Cypress QA"
            echo ""
            echo "| pruebas | fallas | errores | omitidas |"
            echo "| ---: | ---: | ---: | ---: |"
            echo "| $TESTS | $FAILURES | $ERRORS | $SKIPPED |"
            echo ""
            echo "Detalle de pruebas ejecutadas:"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ -n "$TEST_CASES" ]; then
            while IFS= read -r test_case; do
              [ -n "$test_case" ] && echo "- $test_case" >> "$GITHUB_STEP_SUMMARY"
            done <<< "$TEST_CASES"
          else
            echo "- No disponible" >> "$GITHUB_STEP_SUMMARY"
          fi

          {
            echo ""
            echo "Pruebas fallidas:"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ -n "$FAILED_TEST_CASES" ]; then
            while IFS= read -r failed_case; do
              [ -n "$failed_case" ] && echo "- $failed_case" >> "$GITHUB_STEP_SUMMARY"
            done <<< "$FAILED_TEST_CASES"
          else
            echo "- Ninguna" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload Cypress artifacts on QA failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-qa-failure-artifacts
          path: |
            front/cypress/screenshots
            front/cypress/videos
          if-no-files-found: ignore

  deploy-prod:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: [resolve-run, deploy-qa]
    if: needs.resolve-run.outputs.deploy_prod == 'true'
    environment: production
    steps:
      - name: Download front artifact from CI run
        uses: actions/download-artifact@v4
        with:
          name: front-dist
          run-id: ${{ needs.resolve-run.outputs.source_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: artifacts/front-dist

      - name: Download back artifact from CI run
        uses: actions/download-artifact@v4
        with:
          name: back-dist
          run-id: ${{ needs.resolve-run.outputs.source_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: artifacts/back-dist

      - name: Verify artifacts
        run: |
          test -d artifacts/front-dist
          test -d artifacts/back-dist
          echo "Artifacts from CI run ${{ needs.resolve-run.outputs.source_run_id }} ready"

      - name: Trigger Render deploy (Back PROD)
        run: |
          curl --fail --show-error --silent \
            -X POST "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID_BACK_PROD }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{}'

      - name: Trigger Render deploy (Front PROD)
        run: |
          curl --fail --show-error --silent \
            -X POST "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID_FRONT_PROD }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{}'

      - name: Wait and health check PROD
        run: |
          for i in {1..20}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.BACK_PROD_URL }}/health" || true)
            if [ "$code" = "200" ]; then
              echo "Production health check OK"
              exit 0
            fi
            echo "Production not ready yet (attempt $i), code=$code"
            sleep 15
          done
          echo "Production health check failed"
          exit 1
